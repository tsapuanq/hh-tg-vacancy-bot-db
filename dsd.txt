# #publisher.py
# import asyncio
# import random
# import logging
# from telegram import Bot
# from src.config import TELEGRAM_BOT_TOKEN, CHANNEL_USERNAME
# from src.llm_summary import summarize_description_llm, filter_vacancy_llm
# from database import Database
# import os

# # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
# logging.basicConfig(level=logging.INFO)


# # ‚Äî‚Äî‚Äî –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è –∫–æ–Ω–≤–µ—Ä—Å–∏—è LLM-—Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ Markdown-–±—É–ª–ª–µ—Ç—ã ‚Äî‚Äî‚Äî
# def _to_bullets(x) -> str:
#     if isinstance(x, list):
#         lines = x
#     else:
#         lines = x.split("\n") if isinstance(x, str) else [x]
#     bullets = []
#     for item in lines:
#         s = str(item).strip().strip("'\"")
#         if s and s != "–ù–µ —É–∫–∞–∑–∞–Ω–æ":
#             bullets.append(f"‚Ä¢ {s}")
#     return "\n".join(bullets) or "–ù–µ —É–∫–∞–∑–∞–Ω–æ"


# # ‚Äî‚Äî‚Äî –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∞–∫–∞–Ω—Å–∏–∏ –¥–ª—è Telegram ‚Äî‚Äî‚Äî
# def format_message(data: dict, summary: dict) -> str:
#     title = f"**{data.get('title','---')}**"
#     pub_date = f"**{data.get('published_at','---')}**"
#     resp = _to_bullets(summary.get("responsibilities", "–ù–µ —É–∫–∞–∑–∞–Ω–æ"))
#     reqs = _to_bullets(summary.get("requirements", "–ù–µ —É–∫–∞–∑–∞–Ω–æ"))
#     about = str(summary.get("about_company", "–ù–µ —É–∫–∞–∑–∞–Ω–æ")).strip().strip("'\"")

#     return f"""
# üåê *–ì–æ—Ä–æ–¥:* {data.get('location', '---')}
# üìÖ *–î–æ–ª–∂–Ω–æ—Å—Ç—å:* {title}
# üíº *–ö–æ–º–ø–∞–Ω–∏—è:* {data.get('company', '---')}
# üí∞ *–ó–ü:* {data.get('salary_range') or data.get('salary') or '---'}

# üéì *–û–ø—ã—Ç:* {data.get('experience', '---')}
# üìÇ *–¢–∏–ø –∑–∞–Ω—è—Ç–æ—Å—Ç–∏:* {data.get('employment_type', '---')}
# üìÜ *–ì—Ä–∞—Ñ–∏–∫:* {data.get('schedule', '---')}
# üïí *–†–∞–±–æ—á–∏–µ —á–∞—Å—ã:* {data.get('working_hours', '---')}
# üè† *–§–æ—Ä–º–∞—Ç —Ä–∞–±–æ—Ç—ã:* {data.get('work_format', '---')}
# üìÖ *–î–∞—Ç–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏:* {pub_date}

# üßæ *–û–±—è–∑–∞–Ω–Ω–æ—Å—Ç–∏:*
# {resp}

# üéØ *–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:*
# {reqs}

# üè¢ *–û –∫–æ–º–ø–∞–Ω–∏–∏:*
# {about}

# üîé [–ü–æ–¥—Ä–æ–±–Ω–µ–µ –Ω–∞ hh]({data['url']})
# """.strip()


# async def main(db):
#     conn = db.get_connection()
#     cursor = conn.cursor()

#     # –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏
#     cursor.execute(
#         """
#         SELECT id, title, description
#         FROM vacancies
#         WHERE is_relevant IS NULL AND processed_at >= CURRENT_DATE
#     """
#     )
#     rows = cursor.fetchall()
#     for row in rows:
#         vacancy_id, title, description = row
#         is_relevant = filter_vacancy_llm(title, description)
#         logging.info(f"[Gemini Filter] {title} ‚Üí {'‚úÖ' if is_relevant else '‚ùå'}")
#         if is_relevant:
#             cursor.execute(
#                 "UPDATE vacancies SET is_relevant = TRUE WHERE id = %s", (vacancy_id,)
#             )
#         else:
#             cursor.execute("DELETE FROM vacancies WHERE id = %s", (vacancy_id,))
#         await asyncio.sleep(4.5)  # –õ–∏–º–∏—Ç 15 rpm
#     conn.commit()

#     # –®–∞–≥ 2: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—É–º–º–∞—Ä–∏
#     cursor.execute(
#         """
#         SELECT id, description
#         FROM vacancies
#         WHERE is_relevant = TRUE AND (summary_duties IS NULL OR summary_requirements IS NULL OR summary_company IS NULL)
#     """
#     )
#     rows = cursor.fetchall()
#     for row in rows:
#         vacancy_id, description = row
#         summary = summarize_description_llm(description)
#         cursor.execute(
#             """
#             UPDATE vacancies
#             SET summary_duties = %s, summary_requirements = %s, summary_company = %s
#             WHERE id = %s
#         """,
#             (
#                 summary["responsibilities"],
#                 summary["requirements"],
#                 summary["about_company"],
#                 vacancy_id,
#             ),
#         )
#     conn.commit()

#     # –®–∞–≥ 3: –ü—É–±–ª–∏–∫–∞—Ü–∏—è
#     cursor.execute(
#         """
#         SELECT id, title, company, location, salary, salary_range, experience, employment_type, schedule, 
#                working_hours, work_format, published_at, summary_duties, summary_requirements, 
#                summary_company, url
#         FROM vacancies
#         WHERE is_relevant = TRUE AND processed_at >= CURRENT_DATE AND NOT sent_to_telegram
#     """
#     )
#     rows = cursor.fetchall()
#     if not rows:
#         logging.info("‚ÑπÔ∏è –°–µ–≥–æ–¥–Ω—è –Ω–µ—Ç –Ω–æ–≤—ã—Ö –≤–∞–∫–∞–Ω—Å–∏–π –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏.")
#         db.return_connection(conn)
#         return

#     bot = Bot(token=TELEGRAM_BOT_TOKEN)
#     for idx, row in enumerate(rows, 1):
#         data = {
#             "id": row[0],
#             "title": row[1],
#             "company": row[2],
#             "location": row[3],
#             "salary": row[4],
#             "salary_range": row[5],
#             "experience": row[6],
#             "employment_type": row[7],
#             "schedule": row[8],
#             "working_hours": row[9],
#             "work_format": row[10],
#             "published_at": row[11],
#             "summary_duties": row[12],
#             "summary_requirements": row[13],
#             "summary_company": row[14],
#             "url": row[15],
#         }
#         summary = {
#             "responsibilities": data["summary_duties"],
#             "requirements": data["summary_requirements"],
#             "about_company": data["summary_company"],
#         }
#         text = format_message(data, summary)
#         try:
#             await bot.send_message(
#                 chat_id=CHANNEL_USERNAME, text=text, parse_mode="Markdown"
#             )
#             logging.info(f"‚úÖ [{idx}/{len(rows)}] –í–∞–∫–∞–Ω—Å–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.")
#             cursor.execute(
#                 "UPDATE vacancies SET sent_to_telegram = TRUE WHERE id = %s",
#                 (data["id"],),
#             )
#             conn.commit()
#         except Exception as e:
#             logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram: {e}")
#             continue

#         if idx < len(rows):
#             delay = max(4.0, random.uniform(4, 10))
#             logging.info(f"‚è±Ô∏è –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π: {delay:.2f} —Å–µ–∫.")
#             await asyncio.sleep(delay)

#     try:
#         logging.info("‚è≥ –£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –≤–∞–∫–∞–Ω—Å–∏–π, –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –≤ Telegram...")

#         cursor.execute("DELETE FROM vacancies WHERE sent_to_telegram = FALSE")
#         deleted_count = cursor.rowcount
#         conn.commit()

#         if deleted_count > 0:
#             logging.info(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ {deleted_count} –Ω–µ–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –≤–∞–∫–∞–Ω—Å–∏–π")

#     except Exception as e:
#         logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –≤–∞–∫–∞–Ω—Å–∏–π: {e}")
#         conn.rollback()

#     finally:
#         db.return_connection(conn)

#     logging.info(f"üì¨ –í—Å–µ–≥–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {len(rows)} –≤–∞–∫–∞–Ω—Å–∏–π.")


# def run_publisher(db):
#     return asyncio.run(main(db))


# if __name__ == "__main__":
#     db = Database(os.getenv("DATABASE_URL"))
#     run_publisher(db)

